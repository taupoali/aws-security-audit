#!/usr/bin/env python3

import csv
import json
from pathlib import Path
import argparse
import re

def load_multi_hop_paths():
    """Load multi-hop paths from analysis"""
    paths_file = Path("cross_account_multi_hop_paths_detailed.csv")
    if not paths_file.exists():
        print("Warning: cross_account_multi_hop_paths_detailed.csv not found")
        print("Run analyze_cross_account_escalation.py first")
        return []
    
    paths = []
    with open(paths_file, 'r', newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            paths.append(row)
    
    print(f"Loaded {len(paths)} multi-hop paths")
    return paths

def load_permission_set_analysis():
    """Load permission set analysis from all accounts"""
    analysis_files = list(Path('.').glob('permission_set_analysis_*.csv'))
    all_analysis = []
    
    for file in analysis_files:
        with open(file, 'r', newline='', encoding='utf-8') as f:
            reader = csv.DictReader(f)
            for row in reader:
                all_analysis.append(row)
    
    print(f"Loaded {len(all_analysis)} permission set analyses from {len(analysis_files)} accounts")
    return all_analysis

def load_identity_center_assignments():
    """Load Identity Center assignments"""
    assignments_file = Path("findings/identity_center_assignments.csv")
    if not assignments_file.exists():
        print("Warning: identity_center_assignments.csv not found")
        return []
    
    assignments = []
    with open(assignments_file, 'r', newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            assignments.append(row)
    
    print(f"Loaded {len(assignments)} Identity Center assignments")
    return assignments

def load_user_mappings():
    """Load user mappings for readable names"""
    user_file = Path("data_collected/identity_center_user_mapping.csv")
    if not user_file.exists():
        return {}
    
    users = {}
    with open(user_file, 'r', newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        for row in reader:
            users[row['PrincipalId']] = {
                'username': row['Username'],
                'display_name': row['DisplayName']
            }
    
    return users

def extract_assume_role_permissions(policy_document):
    """Extract sts:AssumeRole permissions from policy document"""
    if not policy_document:
        return []
    
    try:
        policy = json.loads(policy_document)
    except:
        return []
    
    assume_role_permissions = []
    
    for statement in policy.get('Statement', []):
        if statement.get('Effect') != 'Allow':
            continue
        
        actions = statement.get('Action', [])
        if isinstance(actions, str):
            actions = [actions]
        
        resources = statement.get('Resource', [])
        if isinstance(resources, str):
            resources = [resources]
        
        # Check for AssumeRole actions
        assume_role_actions = []
        for action in actions:
            if action in ['*', 'sts:*', 'sts:AssumeRole']:
                assume_role_actions.append(action)
        
        if assume_role_actions:
            for resource in resources:
                assume_role_permissions.append({
                    'action': assume_role_actions,
                    'resource': resource
                })
    
    return assume_role_permissions

def check_role_assumable(role_arn, assume_role_permissions):
    """Check if a role ARN is assumable given the permissions"""
    for perm in assume_role_permissions:
        resource = perm['resource']
        
        # Check for wildcard permissions
        if resource == '*':
            return True, 'Wildcard resource (*)'
        
        # Check for exact match
        if resource == role_arn:
            return True, f'Exact match: {resource}'
        
        # Check for pattern match (e.g., arn:aws:iam::*:role/*)
        if '*' in resource:
            # Convert resource pattern to regex
            pattern = resource.replace('*', '.*')
            if re.match(pattern, role_arn):
                return True, f'Pattern match: {resource}'
    
    return False, 'No matching permissions'

def find_exploitable_paths(paths, permission_analysis, assignments, users):
    """Find which multi-hop paths are actually exploitable"""
    exploitable_paths = []
    
    # Create permission set to policy mapping
    perm_set_policies = {}
    for analysis in permission_analysis:
        account_id = analysis['AccountId']
        perm_set = analysis['PermissionSetName']
        policy_doc = analysis['PolicyDocument']
        
        key = f"{account_id}:{perm_set}"
        if key not in perm_set_policies:
            perm_set_policies[key] = []
        
        assume_role_perms = extract_assume_role_permissions(policy_doc)
        perm_set_policies[key].extend(assume_role_perms)
    
    # Create user to permission set mapping
    user_perm_sets = {}
    for assignment in assignments:
        principal_id = assignment['PrincipalId']
        account_id = assignment['AccountId']
        perm_set = assignment['PermissionSetName']
        
        if principal_id not in user_perm_sets:
            user_perm_sets[principal_id] = []
        
        user_perm_sets[principal_id].append({
            'account_id': account_id,
            'perm_set': perm_set
        })
    
    # Check each multi-hop path
    for path in paths:
        source_account = path['source_account']
        intermediate_account = path['intermediate_account']
        final_account = path['final_account']
        
        hop1_role = path['hop1_trusting_role']
        hop2_role = path['hop2_trusting_role']
        
        # Build role ARNs
        hop1_role_arn = f"arn:aws:iam::{intermediate_account}:role/{hop1_role}"
        hop2_role_arn = f"arn:aws:iam::{final_account}:role/{hop2_role}"
        
        # Check if any user can exploit this path
        exploiting_users = []
        
        for principal_id, perm_set_assignments in user_perm_sets.items():
            # Check if user has access to source account
            source_perm_sets = [ps for ps in perm_set_assignments if ps['account_id'] == source_account]
            
            for source_ps in source_perm_sets:
                source_key = f"{source_account}:{source_ps['perm_set']}"
                source_permissions = perm_set_policies.get(source_key, [])
                
                # Check if can assume hop1 role
                can_hop1, hop1_reason = check_role_assumable(hop1_role_arn, source_permissions)
                
                if can_hop1:
                    # Check if user also has access to intermediate account for hop2
                    intermediate_perm_sets = [ps for ps in perm_set_assignments if ps['account_id'] == intermediate_account]
                    
                    for intermediate_ps in intermediate_perm_sets:
                        intermediate_key = f"{intermediate_account}:{intermediate_ps['perm_set']}"
                        intermediate_permissions = perm_set_policies.get(intermediate_key, [])
                        
                        # Check if can assume hop2 role
                        can_hop2, hop2_reason = check_role_assumable(hop2_role_arn, intermediate_permissions)
                        
                        if can_hop2:
                            user_info = users.get(principal_id, {})
                            exploiting_users.append({
                                'principal_id': principal_id,
                                'username': user_info.get('username', 'Unknown'),
                                'display_name': user_info.get('display_name', 'Unknown'),
                                'source_perm_set': source_ps['perm_set'],
                                'intermediate_perm_set': intermediate_ps['perm_set'],
                                'hop1_reason': hop1_reason,
                                'hop2_reason': hop2_reason
                            })
        
        if exploiting_users:
            for user in exploiting_users:
                exploitable_paths.append({
                    'source_account': source_account,
                    'intermediate_account': intermediate_account,
                    'final_account': final_account,
                    'hop1_role': hop1_role,
                    'hop2_role': hop2_role,
                    'attack_path': path['attack_path'],
                    'exploitable': 'YES',
                    'principal_id': user['principal_id'],
                    'username': user['username'],
                    'display_name': user['display_name'],
                    'source_perm_set': user['source_perm_set'],
                    'intermediate_perm_set': user['intermediate_perm_set'],
                    'hop1_permission_reason': user['hop1_reason'],
                    'hop2_permission_reason': user['hop2_reason'],
                    'risk_level': 'CRITICAL'
                })
        else:
            # Path exists but no exploiting users found
            exploitable_paths.append({
                'source_account': source_account,
                'intermediate_account': intermediate_account,
                'final_account': final_account,
                'hop1_role': hop1_role,
                'hop2_role': hop2_role,
                'attack_path': path['attack_path'],
                'exploitable': 'NO',
                'principal_id': '',
                'username': '',
                'display_name': '',
                'source_perm_set': '',
                'intermediate_perm_set': '',
                'hop1_permission_reason': 'No users with AssumeRole permission',
                'hop2_permission_reason': 'No users with AssumeRole permission',
                'risk_level': 'LOW'
            })
    
    return exploitable_paths

def main():
    parser = argparse.ArgumentParser(description='Validate which multi-hop paths are actually exploitable')
    args = parser.parse_args()
    
    print("=== Exploitable Path Validation ===")
    
    # Load all data
    paths = load_multi_hop_paths()
    permission_analysis = load_permission_set_analysis()
    assignments = load_identity_center_assignments()
    users = load_user_mappings()
    
    if not paths:
        print("No multi-hop paths to validate")
        return
    
    # Find exploitable paths
    exploitable_paths = find_exploitable_paths(paths, permission_analysis, assignments, users)
    
    # Save results
    with open('exploitable_escalation_paths.csv', 'w', newline='', encoding='utf-8') as f:
        fieldnames = [
            'source_account', 'intermediate_account', 'final_account',
            'hop1_role', 'hop2_role', 'attack_path', 'exploitable',
            'principal_id', 'username', 'display_name',
            'source_perm_set', 'intermediate_perm_set',
            'hop1_permission_reason', 'hop2_permission_reason', 'risk_level'
        ]
        writer = csv.DictWriter(f, fieldnames=fieldnames)
        writer.writeheader()
        writer.writerows(exploitable_paths)
    
    # Generate summary
    total_paths = len(paths)
    exploitable_count = len([p for p in exploitable_paths if p['exploitable'] == 'YES'])
    theoretical_count = total_paths - exploitable_count
    
    print(f"\n=== Validation Results ===")
    print(f"Total multi-hop paths analyzed: {total_paths}")
    print(f"Actually exploitable paths: {exploitable_count}")
    print(f"Theoretical-only paths: {theoretical_count}")
    
    if exploitable_count > 0:
        print(f"\n🚨 CRITICAL: {exploitable_count} paths are actually exploitable!")
        print(f"Users who can exploit paths:")
        
        exploiting_users = set()
        for path in exploitable_paths:
            if path['exploitable'] == 'YES':
                exploiting_users.add(f"{path['username']} ({path['display_name']})")
        
        for user in sorted(exploiting_users):
            print(f"  - {user}")
        
        print(f"\nImmediate actions required:")
        print(f"1. Review exploitable_escalation_paths.csv")
        print(f"2. Remove AssumeRole permissions from source_perm_set and intermediate_perm_set")
        print(f"3. Or remove the cross-account trust relationships")
    else:
        print(f"\n✅ GOOD: No paths are actually exploitable")
        print(f"All multi-hop paths are theoretical only - no users have the required permissions")
    
    print(f"\nFile created: exploitable_escalation_paths.csv")

if __name__ == "__main__":
    main()